'''
不得不说，这是一个很棒的算法题目，完全未知的状态去做它的话，会像我一样思考很多很多。
我开始隐约觉得它可以贪心，但是不知道是贪哪里，贪最大的一支箭的覆盖层数？这样可以减少
掉最多的气球，从单个箭的角度来看。举了几个例子发现不对，即使是挑覆盖最多的层去射，仍
会出现射完了把连续的气球给射成几段，还要回头去射它们，浪费了。

遇事不决，DP试一试？nothing
然后就是一些观察和发现，慢慢摸索这个题目的特性。1.每个射出的箭其实都是可以设在气球的任意
左右端点。2.单调栈去算每个端点的重叠覆盖的层数。很麻烦且是O(n^2) 然后突然想到一个问题。

什么时候必须射箭了呢？结合上面2点就是如果是按右端点升序排列，到了每一个气球的右端点且它
右边的气球和它是不重叠的，这时候就要必须去射箭了。另一个情况就是右边的气球是和当前气球有
相交地方，这种情况虽然是本气球不一定要射，可以在后面的气球的左部和它重叠的地方射，但是
那样也相当于是在当前气球的右端点射出的，毕竟重叠区域是有你有我的嘛。

问题直接解决了，因为必须射出一箭就是返回值+1嘛。然后注意的就是代码逻辑别写错了。我好久不写
算法，整个的编码能力简直是弱爆级别的。
'''
from typing import List


class Solution:
    def findMinArrowShots(self, points: List[List[int]]) -> int:
        if not points:
            return 0
        points.sort(key=lambda i: (i[1], i[0]))     # 这里直接lambda i: i[1]
        res = 0
        # t = points[0][1]
        pre = points[0][1]
        for cur in points:
            if pre < cur[0]:
                res += 1
                pre = cur[1]  # ???
        return res + 1

