'''
这题非常有趣（解决的逻辑很有用，算是），但是这又是不太好处理的NP又不是NP，就是
a1p1 + a2p2 + a3p3 +...+ anpn = min_price (a1-an为选择的数目，p1-pn是确定的每个
大礼包会节省的钱）
还有一个表达式就是大礼包中每个种类的数目和要小于等于 needs，这第二个就使得问题无法贪心去解决，
即使最省钱的大礼包买的最多，但是由于大礼包数目的限制是不确定的，可能出现最省钱的大礼包卡住了后面
要购买的数目，不如用多个次省钱的大礼包的方案省钱。就是一定要遍历。就是要累计算机，但是如果更好的
计算呢？最基础的肯定就是不负责的dfs，从目标要求的needs而来去下层递归自己，嗯py有lru_cache
去记忆化的递归好些。  我想的算法是用字典去存，消耗某些数目a1-an的一个n元组的最低价格，然后这些
方案的算法是每个去遍历各种大礼包，用更小的数目的价格去加大礼包的价格，或是在相邻的数目价格的基础上
加某种物品的单价，也很傻，这么看来就是dfs的反过来的一种实现。
'''
from typing import List
class Solution:
    def shoppingOffers(self, price: List[int], special: List[List[int]], needs: List[int]) -> int:
        pass