'''
https://leetcode-cn.com/problems/gray-code/solution/gray-code-jing-xiang-fan-she-fa-by-jyd/
采用以上题解的解法了。我通过观察1的个数发现格雷码的1的数量是符合二项式系数的，然后从它每一个生成的过程发现它的更替位置是按照
插值的规律来的，最初是0，然后是在它前面插入1后面再补充1，101之后是在每个数字前面插入2最后再补个2，循环下去，所求的序列每次
格雷码根据前一个格雷码所更新的位置，比如三位的格雷码它的数字就有012三个位序，序列是2120212，从左向右更新该位置的值即可得到
后面一个，这是我的算法，而且还有个发现就是2120之后的位序还可以是121，只要是符合数量上有一个位置走的是n的二项式系数就可以。

网址的思路叫镜像观察法，它是从递归的角度从结果的角度处理的，就是把每次的格雷码的整数形式保留到当前的结果中，然后倒置再在前面加
左移过n位的1，就是把二进制的1加到原来结果上，但它这个倒置的操作需要一定的观察力。这个做法和我一样都是需要递归，但是都可以通过
循环来避免递归子函数。但它比我好在，我的递归得到的位序还要执行2^n，即把所有位置的位序修改具体操作一遍，和它这个递归出来就是结
果感觉要啰嗦一些。以下是它的代码。
'''
class Solution:
    def grayCode(self, n: int) -> List[int]:
        res, head = [0], 1
        for i in range(n):
            for j in range(len(res) - 1, -1, -1):
                res.append(head + res[j])
            head <<= 1
        return res
