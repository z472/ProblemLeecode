class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right
'''
题目明确说是只有两个位置顺序出错。还要求不要用sc=O(n)的来写。我的想法和官方题解第一个完全一致，先中序遍历得到出错的位置，再
次进行遍历取得两个错误位置。不过没有考虑到从输出的列表发现位置的特殊情况。我以为是有两个位置不符合单调。但实际上也有仅一个位置
不符合的情况。不过那样的话就是不符合的那个位置和它前面的位置交换值。      sc=O(n)的是在此基础上的优化。仍是靠着中序遍历的异常
顺序来确定错误的结点位置，不过这是在遍历过程中发现的，具体是关注中序遍历过程当中最后一个值与前一个值是否是大于前值。      感觉
是你的思路还没有一种优化的习惯，我是想出一种解法，然后完全放弃它去另外构建解法，还是缺少习惯。     不过理论上还是有sc=O(1)的
解法，就是之前遇到过的，要遍历两次结点且空间sc=O(1)的。莫里斯算法。遍历是它，然后具体还是要上面第二种的做法。
'''

class Solution:
    def recoverTree(self, root: TreeNode) -> None:
