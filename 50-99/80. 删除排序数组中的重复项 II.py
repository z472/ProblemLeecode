'''
    正常状态没有多余要调换的值时是pl == pr
    异常状态是有多余的要被放到后面的小值时是pl < pr
    # 长度为1没进入循环，长度大于1的又非常符合循环，巧合
    （第二次我用cou来做核心if判断，第一次就更离谱了，好像是让初始pl,pr为0,1然后比较二者是否相等。）
    一次过的，但是编码改了三次，思路也逐渐清晰，之前总出错的点是在有多余的数字被交换修改之后，逻辑混乱主要当时的pl,pr的指代和循环中if
    的条件都不正确，发现错误之后不知道走到哪里去修改，全是特例的补丁,现在看来就是没有一个找到当前正在更新的数的写法。
    后来发现用pl标记保存好的数的后一位，pl-1位置就是当前变量,pl相当于是遍历未知数的第一个，所以核心的if是nums[pl-1] == nums[pl]
    具体做法是比较pl与pl-1，如果没有连续3个的值就pl,pr同增且二者相等；如果有连续3个值就pl原地待命，pr去增加，然后要细心按照不同情况
    来交换维护cou变量等内容。下面讲个代码的细节
        巧合一：第二个else的elif后面语句存在我遗漏表达的一个逻辑，即正常状态下新发现一个值，巧合的是更新变量居然没错
    原本设计是给它上两行的情况准备的，异常状态下发现个新值，此时pr>pl，更新变量

    这道题的发现，一：对于复杂的逻辑的题，要在本上想好，不要着急上去就写。二：随着多余量（连续3个甚至更多）的出现，也会出现很多你最初没
    想到的情况，让你完全没法在原来基础上改，原因就是没抓到核心的东西，逻辑复杂特例很多多数都是你混乱了，还有更好的想法。三：这道题有个有
    趣的现象，一旦出现多余的数要往后面搬运就不会有之前正常的情况出现了，pl=pr时多数都在if中执行，只有那个巧合那里我没设计但是却要跑那里
    去，而异常情况就一直会在else里执行了。

    执行用时：40 ms, 在所有 Python3 提交中击败了76.18%的用户
    内存消耗：15 MB, 在所有 Python3 提交中击败了5.26%的用户
    # 第40行加了一个判断，因为在pl,pr相等时这么写相当于没写。结果速度直接慢了了10%，从40ms变到了44ms，看来程序说废话和判断要不要说废话
    的时间还是直接说废话来的快啊。
    题目要求：不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成
    我只用了三个变量，不知道内存消耗都是哪来的，费了牛劲搞出来的东西就是要避免浪费空间还偏偏空间使用多。

    官方题解：
'''


class Solution:
    def removeDuplicates(self, nums):
        # nums: List[int]) -> int:
        pl, pr, cou = 1, 1, 1
        while pr < len(nums):
            if nums[pl - 1] == nums[pl]:
                if cou < 2:
                    cou += 1
                    pr, pl = pr + 1, pl + 1
                else:
                    pr += 1
                    if pr < len(nums) and nums[pr] > nums[pl - 1]:
                        nums[pl], nums[pr] = nums[pr], nums[pl]
                        cou, pl, pr = 1, pl + 1, pr + 1
            else:
                if nums[pr] == nums[pl - 1]:
                    if cou < 2:  # 很多小的if判断都是靠测试输入来发现的
                        nums[pl], nums[pr] = nums[pr], nums[pl]
                        cou, pl, pr = cou + 1, pl + 1, pr + 1
                    else:
                        pr += 1
                elif nums[pr] > nums[pl - 1]:
                    # if pl != pr:
                    nums[pl], nums[pr] = nums[pr], nums[pl]
                    cou, pl, pr = 1, pl + 1, pr + 1

        return pl


a = Solution()
mt1 = ([1, 2, 2, 2, 3, 3, 4, 4, 4, 4, 5, 6, 6], [1, 1, 2, 3, 3, 4], [1, 1, 1])
mt2 = ([1, 1, 1], [1, 2, 2], [1, 1], [1])
for i in mt1:
    print('in:\n', i)
    print(i[:a.removeDuplicates(i)])
